#!/usr/bin/env python3
import argparse
import logging
import sys
import time

import kubernetes
from kubernetes.client.rest import ApiException
from kubernetes.utils import parse_quantity

from benji.helpers.kubernetes import create_pvc, determine_rbd_image_location
from benji.helpers.settings import benji_log_level
from benji.helpers.utils import subprocess_run, setup_logging

PVC_CREATION_TRIES = 30
PVC_CREATION_WAIT = 2

setup_logging()
logger = logging.getLogger()

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, allow_abbrev=False)

parser.add_argument('-f',
                    '--force',
                    dest='force',
                    action='store_true',
                    default=False,
                    help='Overwrite content of existing persistent volume')

parser.add_argument(metavar='version_uid', dest='version_uid', help='Version uid')
parser.add_argument(metavar='pvc_namespace', dest='pvc_namespace', help='PVC namespace')
parser.add_argument(metavar='pvc_name', dest='pvc_name', help='PVC name')
parser.add_argument(metavar='storage_class', dest='storage_class', help='Storage class for the new PVC')

args = parser.parse_args()

benji_ls = subprocess_run(
    ['benji', '--machine-output', '--log-level', benji_log_level, 'ls', f'uid == "{args.version_uid}"'],
    decode_json=True)

if len(benji_ls['versions']) == 0:
    raise RuntimeError(f'Version {args.version_uid} is not known to Benji.')

version = benji_ls['versions'][0]
version_size = version['size']

logger.info(f'Restoring version {args.version_uid} to PVC {args.pvc_namespace}/{args.pvc_name}.')

# This assumes that the Kubernetes client has already been initialized
core_v1_api = kubernetes.client.CoreV1Api()
pvc = None
try:
    pvc = core_v1_api.read_namespaced_persistent_volume_claim(args.pvc_name, args.pvc_namespace)
except ApiException as exception:
    if exception.status != 404:
        raise RuntimeError(f'Unexpected Kubernetes API exception: {str(exception)}')

if pvc is None:
    logger.info(f'Trying to create PVC {args.pvc_namespace}/{args.pvc_name} (storage class {args.storage_class}).')
    pvc = create_pvc(pvc_name=args.pvc_name,
                     pvc_namespace=args.pvc_namespace,
                     pvc_size=version_size,
                     storage_class_name=args.storage_class)

    for _ in range(PVC_CREATION_TRIES):
        # Probably should use a watch instead of polling
        pvc = core_v1_api.read_namespaced_persistent_volume_claim(args.pvc_name, args.pvc_namespace)
        if pvc.status.phase == 'Bound':
            break
        logger.info('Waiting for persistent volume creation...')
        time.sleep(PVC_CREATION_WAIT)
    else:
        logger.error(f'PVC is still not provisioned after {PVC_CREATION_TRIES * PVC_CREATION_WAIT} seconds.')
        logger.info(f'Deleting PVC {args.pvc_namespace}/{args.pvc_name}.')
        core_v1_api.delete_namespaced_persistent_volume_claim(args.pvc_name, args.pvc_namespace)
else:
    if not args.force:
        raise RuntimeError('PVC already exists. Will not overwrite it unless forced.')

    if pvc.status.phase != 'Bound':
        raise RuntimeError('PVC is not bound to a volume.')

    pvc_size = int(parse_quantity(pvc.status.capacity['storage']))
    if pvc_size < version_size:
        raise RuntimeError(f'Existing PVC is too small to hold version {args.version_uid} ({pvc_size} < {version_size}).')
    elif pvc_size > version_size:
        logger.warning(f'Existing PVC is {pvc_size - version_size} bytes bigger than version {args.version_uid}.')

pv = core_v1_api.read_persistent_volume(pvc.spec.volume_name)
pool, image = determine_rbd_image_location(pv)

if pool is None or image is None:
    raise RuntimeError(f'Cannot determine RBD pool and image of PersistentVolume {pv.metadata.name}.')

subprocess_run([
    'benji', '--log-level', benji_log_level, 'restore', '--sparse', '--force', args.version_uid, f'{pool}:{pool}/{image}'
])
sys.exit(0)
